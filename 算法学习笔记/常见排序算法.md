# 常见排序算法详解



### 冒泡排序

代码：

```Java
public class BubbleSort {
    public static int[] BubbleSort(int[] nums) {
        for (int i = 0; i <nums.length-1 ; i++) {
            boolean swap = false;
            for (int j = i+1; j < nums.length; j++) {
                if(nums[i]>nums[j]){
                    int num = nums[i];
                    nums[i] = nums[j];
                    nums[j] = num;
                    swap = true;
                }
            }
            //优化点： // 如果某次未发生数据交换，说明数据已排序
            if(!swap){
                break;
            }
        }
        return nums;
    }
}
```
  
冒泡排序的特点

稳定性：
它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。
冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。

空间复杂度：
由于整个排序过程是在原数据上进行操作，故为 O(1);

时间复杂度：
由于嵌套了 2 层循环，故为 O(n*n);


### 选择排序
代码：
```Java
public class SelectSort {
    public static int[] SelectSort(int[] nums) {
        int len = nums.length;
        int index, temp;
        for (int i = 0; i < len - 1; i++) {
            index = i;
            for (int j = i + 1; j < len; j++) {
                if (nums[j] < nums[index]) {
                    index = j;
                }
            }
            if (index != i) {
                temp = nums[i];
                nums[i] = nums[index];
                nums[index] = temp;
            }
        }
        return nums;
    }
}
```
选择排序的特点

稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。

空间复杂度：在原序列进行操作，故为 O( 1 );

时间复杂度：需要 2 次循环遍历，故为 O( n * n );


# 冒泡排序和选择排序的区别

一: 区别
1.冒泡排序是比较相邻位置的两个数，而选择排序是按顺序比较，找最大值或者最小值；

2.冒泡排序每一轮比较后，位置不对都需要换位置，选择排序每一轮比较都只需要换一次位置；

3.冒泡排序是通过数去找位置，选择排序是给定位置去找数；

二: 冒泡排序优缺点
 1.优点:比较简单,空间复杂度较低，是稳定的；                 

 2.缺点:时间复杂度太高，效率慢；

三: 选择排序优缺点
1.优点：一轮比较只需要换一次位置；

2.缺点：效率慢，不稳定（举个例子5，8，5，2，9   我们知道第一遍选择第一个元素5会和2交换，那么原序列中2个5的相对位置前后顺序就破坏了）。


















